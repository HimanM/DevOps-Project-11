# -----------------------------
# DevSecOps CI/CD Pipeline
# Comprehensive security-first workflow
# -----------------------------

name: DevSecOps Pipeline

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: us-west-2
  REGISTRY: ghcr.io
  # Image names must be lowercase for GHCR
  FRONTEND_IMAGE: ghcr.io/himanm/devops-project-11-frontend
  BACKEND_IMAGE: ghcr.io/himanm/devops-project-11-backend

permissions:
  contents: write
  packages: write
  security-events: write
  id-token: write

jobs:
  # ===========================================
  # Stage 1: Secret Scanning
  # ===========================================
  secret-scan:
    name: Secret Scanning
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}

  # ===========================================
  # Stage 1.5: Change Detection
  # ===========================================
  changes:
    name: Change Detection
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.filter.outputs.frontend }}
      backend: ${{ steps.filter.outputs.backend }}
      any: ${{ steps.filter.outputs.frontend == 'true' || steps.filter.outputs.backend == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Filter paths
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            frontend:
              - 'frontend/**'
            backend:
              - 'backend/**'

  # ===========================================
  # Stage 2: Frontend Lint & Build
  # ===========================================
  frontend-lint-build:
    name: Frontend Lint & Build
    runs-on: ubuntu-latest
    needs: [secret-scan, changes]
    if: needs.changes.outputs.frontend == 'true'
    defaults:
      run:
        working-directory: frontend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Build application
        run: npm run build

  # ===========================================
  # Stage 3: Backend Lint & Build
  # ===========================================
  backend-lint-build:
    name: Backend Lint & Build
    runs-on: ubuntu-latest
    needs: [secret-scan, changes]
    if: needs.changes.outputs.backend == 'true'
    defaults:
      run:
        working-directory: backend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Check for vulnerabilities
        run: npm audit --audit-level=high || true

  # ===========================================
  # Stage 4: Container Build & Push
  # ===========================================
  container-build-push:
    name: Container Build & Push
    runs-on: ubuntu-latest
    needs: [frontend-lint-build, backend-lint-build, changes]
    if: |
      always() &&
      !contains(needs.*.result, 'failure') &&
      !contains(needs.*.result, 'cancelled')
    outputs:
      frontend_sha: ${{ steps.vars.outputs.frontend_sha }}
      backend_sha: ${{ steps.vars.outputs.backend_sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set variables
        id: vars
        run: |
          # Calculate distinct SHA for each component
          # If changed, it will be HEAD. If not, it's the last commit that touched the dir.
          FRONTEND_SHA=$(git log -n 1 --pretty=format:%h -- frontend/)
          BACKEND_SHA=$(git log -n 1 --pretty=format:%h -- backend/)

          # Fallback if empty (e.g. new repo)
          [ -z "$FRONTEND_SHA" ] && FRONTEND_SHA=$(git rev-parse --short HEAD)
          [ -z "$BACKEND_SHA" ] && BACKEND_SHA=$(git rev-parse --short HEAD)

          echo "frontend_sha=$FRONTEND_SHA" >> $GITHUB_OUTPUT
          echo "backend_sha=$BACKEND_SHA" >> $GITHUB_OUTPUT

          echo "Frontend SHA: $FRONTEND_SHA"
          echo "Backend SHA: $BACKEND_SHA"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract frontend metadata
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.FRONTEND_IMAGE }}
          tags: |
            type=raw,value=latest
            type=raw,value=${{ steps.vars.outputs.frontend_sha }}

      - name: Extract backend metadata
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.BACKEND_IMAGE }}
          tags: |
            type=raw,value=latest
            type=raw,value=${{ steps.vars.outputs.backend_sha }}

      - name: Build and push frontend image
        if: needs.changes.outputs.frontend == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push backend image
        if: needs.changes.outputs.backend == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ===========================================
  # Stage 5: Container Security Scan
  # ===========================================
  container-security-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    needs: [container-build-push, changes]
    if: always() && (needs.container-build-push.result == 'success' || needs.container-build-push.result == 'skipped')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Scan frontend image
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: "${{ env.FRONTEND_IMAGE }}:latest"
          format: "table"
          exit-code: "1"
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH"

      - name: Scan backend image
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: "${{ env.BACKEND_IMAGE }}:latest"
          format: "table"
          exit-code: "1"
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH"

  # ===========================================
  # Stage 6: Terraform Format & Validate
  # ===========================================
  terraform-format-validate:
    name: Terraform Format & Validate
    runs-on: ubuntu-latest
    needs: [secret-scan]
    defaults:
      run:
        working-directory: terraform
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "latest"

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Init
        run: terraform init -backend=false

      - name: Terraform Validate
        run: terraform validate

  # ===========================================
  # Stage 7: IaC Security Scan (Checkov)
  # ===========================================
  iac-security-scan:
    name: IaC Security Scan
    runs-on: ubuntu-latest
    needs: [terraform-format-validate]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Checkov
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: terraform/
          framework: terraform
          output_format: cli
          soft_fail: false
          # Skipped checks for learning project (not production-critical):
          # CKV_AWS_144: S3 cross-region replication
          # CKV_AWS_145: S3 KMS encryption
          # CKV2_AWS_28: WAF protection for ALB
          # CKV_AWS_18: S3 access logging
          # CKV_AWS_21: S3 versioning
          # CKV2_AWS_61: S3 lifecycle configuration
          # CKV2_AWS_62: S3 event notifications
          # CKV_AWS_103: TLS 1.2 for load balancer
          # CKV_AWS_378: HTTP protocol on load balancer
          # CKV2_AWS_20: HTTP to HTTPS redirect
          # CKV_AWS_130: Public IP on subnets
          # CKV2_AWS_12: Default VPC security group
          # CKV_AWS_355: IAM policy resource constraints
          # CKV_AWS_290: IAM write access constraints
          # CKV_AWS_2: ALB HTTPS protocol
          # CKV_AWS_158: CloudWatch log encryption
          # CKV_AWS_338: CloudWatch log retention (1 year)
          # CKV_AWS_289: IAM permissions management
          # CKV_AWS_260: Port 80 ingress from 0.0.0.0/0
          # CKV_AWS_131: ALB drop HTTP headers
          # CKV_AWS_150: Load balancer deletion protection
          # CKV_AWS_91: ELBv2 access logging
          skip_check: CKV_AWS_144,CKV_AWS_145,CKV2_AWS_28,CKV_AWS_18,CKV_AWS_21,CKV2_AWS_61,CKV2_AWS_62,CKV_AWS_103,CKV_AWS_378,CKV2_AWS_20,CKV_AWS_130,CKV2_AWS_12,CKV_AWS_355,CKV_AWS_290,CKV_AWS_2,CKV_AWS_158,CKV_AWS_338,CKV_AWS_289,CKV_AWS_260,CKV_AWS_131,CKV_AWS_150,CKV_AWS_91

  # ===========================================
  # Stage 8: OPA Policy Enforcement
  # ===========================================
  opa-policy-check:
    name: OPA Policy Enforcement
    runs-on: ubuntu-latest
    needs: [terraform-format-validate]
    defaults:
      run:
        working-directory: terraform
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "latest"

      - name: Install Conftest
        run: |
          wget -q https://github.com/open-policy-agent/conftest/releases/download/v0.46.0/conftest_0.46.0_Linux_x86_64.tar.gz
          tar xzf conftest_0.46.0_Linux_x86_64.tar.gz
          sudo mv conftest /usr/local/bin/

      - name: Terraform Init
        run: terraform init

      - name: Generate Terraform Plan JSON
        run: |
          terraform plan -out=tfplan -input=false -var="frontend_image=${{ env.FRONTEND_IMAGE }}:latest" -var="backend_image=${{ env.BACKEND_IMAGE }}:latest" || true
          terraform show -json tfplan > tfplan.json || echo '{"resource_changes":[]}' > tfplan.json

      - name: Run OPA Policy Check
        run: conftest test tfplan.json --policy ../policies/ --all-namespaces

  # ===========================================
  # Stage 9: Terraform Plan
  # ===========================================
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs:
      [
        container-security-scan,
        iac-security-scan,
        opa-policy-check,
        container-build-push,
      ]
    if: "always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && github.ref == 'refs/heads/main' && (needs.container-security-scan.result == 'success' || needs.container-security-scan.result == 'skipped')"
    defaults:
      run:
        working-directory: terraform
    outputs:
      plan-exitcode: ${{ steps.plan.outputs.exitcode }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "latest"

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        id: plan
        env:
          FRONTEND_TAG: ${{ needs.container-build-push.outputs.frontend_sha }}
          BACKEND_TAG: ${{ needs.container-build-push.outputs.backend_sha }}
        run: |
          # Always use the specific image tags (Smart Versioning)
          # If component didn't change, tag is old SHA -> Terraform sees no change -> No Deploy
          # If component changed, tag is new SHA -> Terraform sees change -> Deploy
          terraform plan -out=tfplan -detailed-exitcode \
            -var="frontend_image=${{ env.FRONTEND_IMAGE }}:$FRONTEND_TAG" \
            -var="backend_image=${{ env.BACKEND_IMAGE }}:$BACKEND_TAG" || echo "exitcode=$?" >> $GITHUB_OUTPUT

      - name: Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/tfplan
          retention-days: 5

  # ===========================================
  # Stage 10: Manual Approval
  # ===========================================
  manual-approval:
    name: Manual Approval
    runs-on: ubuntu-latest
    needs: [terraform-plan]
    if: always() && needs.terraform-plan.result == 'success'
    environment: production
    steps:
      - name: Approval checkpoint
        run: echo "Deployment approved for production environment"

  # ===========================================
  # Stage 11: Terraform Apply
  # ===========================================
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [manual-approval, container-build-push]
    if: always() && needs.manual-approval.result == 'success' && (needs.container-build-push.result == 'success' || needs.container-build-push.result == 'skipped')
    defaults:
      run:
        working-directory: terraform
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "latest"

      - name: Terraform Init
        run: terraform init

      - name: Download Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: terraform/

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan

  # ===========================================
  # Stage 12: Post-Deploy Drift Detection
  # ===========================================
  drift-detection:
    name: Drift Detection
    runs-on: ubuntu-latest
    needs: [terraform-apply]
    if: |
      always() &&
      !contains(needs.*.result, 'failure') &&
      !contains(needs.*.result, 'cancelled')
    defaults:
      run:
        working-directory: terraform
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "latest"

      - name: Install Conftest
        run: |
          wget -q https://github.com/open-policy-agent/conftest/releases/download/v0.46.0/conftest_0.46.0_Linux_x86_64.tar.gz
          tar xzf conftest_0.46.0_Linux_x86_64.tar.gz
          sudo mv conftest /usr/local/bin/

      - name: Terraform Init
        run: terraform init

      - name: Detect Drift
        id: drift
        run: |
          terraform plan -detailed-exitcode -out=driftplan || exitcode=$?
          if [ "$exitcode" == "2" ]; then
            echo "drift_detected=true" >> $GITHUB_OUTPUT
            echo "WARNING: Infrastructure drift detected!"
          else
            echo "drift_detected=false" >> $GITHUB_OUTPUT
            echo "No drift detected."
          fi

      - name: Generate Drift Plan JSON
        if: steps.drift.outputs.drift_detected == 'true'
        run: terraform show -json driftplan > driftplan.json

      - name: Re-validate OPA Policies
        if: steps.drift.outputs.drift_detected == 'true'
        run: conftest test driftplan.json --policy ../policies/ --all-namespaces

  # ===========================================
  # Stage 13: Update Image Tags (Bot)
  # ===========================================
  update-image-tags:
    name: Update Image Tags
    runs-on: ubuntu-latest
    needs: [container-build-push]
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Terraform variables
        run: |
          FRONTEND_SHA=${{ needs.container-build-push.outputs.frontend_sha }}
          BACKEND_SHA=${{ needs.container-build-push.outputs.backend_sha }}

          # Update frontend image
          sed -i "s|ghcr.io/himanm/devops-project-11-frontend:[a-zA-Z0-9]*|ghcr.io/himanm/devops-project-11-frontend:${FRONTEND_SHA}|g" terraform/variables.tf

          # Update backend image
          sed -i "s|ghcr.io/himanm/devops-project-11-backend:[a-zA-Z0-9]*|ghcr.io/himanm/devops-project-11-backend:${BACKEND_SHA}|g" terraform/variables.tf

      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add terraform/variables.tf
          git diff --staged --quiet || git commit -m "chore: update image tags [skip ci]"
          git push

  # ===========================================
  # Stage 14: Update README with Deployment Info
  # ===========================================
  update-readme-outputs:
    name: Update README Outputs
    runs-on: ubuntu-latest
    needs: [terraform-apply]
    if: always() && needs.terraform-apply.result == 'success'
    defaults:
      run:
        working-directory: terraform
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "latest"
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init

      - name: Get Terraform Outputs
        id: outputs
        run: |
          # Get outputs as JSON
          FRONTEND_URL=$(terraform output -raw frontend_url 2>/dev/null || echo "Deployment pending")
          ECS_CLUSTER=$(terraform output -raw ecs_cluster_name 2>/dev/null || echo "Not deployed")
          PUBLIC_ALB=$(terraform output -raw public_alb_dns 2>/dev/null || echo "Not deployed")

          echo "frontend_url=${FRONTEND_URL}" >> $GITHUB_OUTPUT
          echo "ecs_cluster=${ECS_CLUSTER}" >> $GITHUB_OUTPUT
          echo "public_alb=${PUBLIC_ALB}" >> $GITHUB_OUTPUT
          echo "timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT

      - name: Update README with Deployment Info
        run: |
          cd ..

          # Create the new deployment section content
          cat > /tmp/deployment_section.md << 'EOF'
          <!-- DEPLOYMENT_OUTPUTS_START -->
          ## Live Deployment

          > **Infrastructure is deployed and running!**

          | Resource | Value |
          |----------|-------|
          | **Frontend URL** | [${{ steps.outputs.outputs.frontend_url }}](${{ steps.outputs.outputs.frontend_url }}) |
          | **ECS Cluster** | `${{ steps.outputs.outputs.ecs_cluster }}` |
          | **AWS Region** | `${{ env.AWS_REGION }}` |
          | **Last Deployed** | ${{ steps.outputs.outputs.timestamp }} |

          <!-- DEPLOYMENT_OUTPUTS_END -->
          EOF

          # Use perl to robustly replace the section (sed can cause duplicates in range matches)
          perl -i -0777 -pe '
            BEGIN { local $/; open(F, "/tmp/deployment_section.md"); $content = <F>; close F; }
            s/<!-- DEPLOYMENT_OUTPUTS_START -->.*<!-- DEPLOYMENT_OUTPUTS_END -->/$content/s
          ' README.md

      - name: Commit and push README
        run: |
          cd ..
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add README.md
          git diff --staged --quiet || git commit -m "docs: update deployment outputs [skip ci]"
          git push
